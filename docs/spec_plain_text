מטלת מחה )ממ"ן( 14
הקורס:   20465 - מעבדה בתכות מערכות
חומר הלימוד למטלה: פרויקט גמר

 
קודות )חובה(
 
משקל המטלה: 61
 
מספר השאלות: 1
 

 
מועד אחרון להגשה: 20.03.2022
 
סמסטר: 2022א
 



 

אחת המטרות העיקריות של הקורס 20465" - מעבדה בתכות מערכות" היא לאפשר ללומדים בקורס להתסות בכתיבת פרויקט תוכה גדול, אשר יחקה את פעולתה של אחת מתוכיות המערכת השכיחות.
עליכם לכתוב תוכת אסמבלר, עבור שפת אסמבלי שתוגדר בהמשך. הפרויקט ייכתב בשפת .C עליכם להגיש את הפריטים הבאים:
.1 קבצי המקור של התוכית שכתבתם )קבצים בעלי סיומת .c או .(.h .2 קובץ הרצה )מקומפל ומקושר( עבור מערכת אובוטו.
.3 קובץ .makefile הקימפול חייב להיות עם הקומפיילר gcc והדגלים: -pedantic -ansi .-Wall יש לפות את כל ההודעות שמוציא הקומפיילר, כך שהתוכית תתקמפל ללא כל הערות או אזהרות.
.4  דוגמאות הרצה )קלט ופלט:(
א.   קבצי קלט בשפת אסמבלי, וקבצי הפלט שוצרו מהפעלת האסמבלר על קבצי קלט
אלה. יש להדגים שימוש במגוון הפעולות וטיפוסי התוים של שפת האסמבלי.
ב.  קבצי קלט בשפת אסמבלי המדגימים מגוון רחב של סוגי שגיאות אסמבלי )ולכן לא וצרים קבצי פלט,( ותדפיסי המסך המראים את הודעות השגיאה שמוציא האסמבלר.

בשל גודל הפרויקט, עליכם לחלק את התוכית למספר קבצי מקור, לפי משימות. יש להקפיד שקוד המקור של התוכית יעמוד בקריטריוים של בהירות, קריאות וכתיבה אה ומובית.
זכיר מספר היבטים חשובים של כתיבת קוד טוב:
.1 הפשטה של מבי התוים: רצוי )ככל האפשר( להפריד בין הגישה למבי התוים לבין המימוש של מבי התוים. כך, למשל, בעת כתיבת פוקציות לטיפול בטבלה, אין זה מעיים של המשתמשים בפוקציות אלה, האם הטבלה ממומשת באמצעות מערך או באמצעות רשימה מקושרת.
.2 קריאות הקוד: יש להשתמש בשמות משמעותיים למשתים ופוקציות. יש לערוך את הקוד באופן מסודר: הזחות עקביות, שורות ריקות להפרדה בין קטעי קוד, וכד.'

.3  תיעוד: יש להכיס בקבצי המקור תיעוד תמציתי וברור, שיסביר את תפקידה של כל פוקציה )באמצעות הערות כותרת לכל פוקציה.( כמו כן יש להסביר את תפקידם של משתים חשובים. כמו כן, יש להכיס הערות ברמת פירוט טובה בכל הקוד.
 
הערה: תוכית "עובדת," דהייו תוכית שמבצעת את כל הדרוש ממה, איה לכשעצמה ערובה לציון גבוה. כדי לקבל ציון גבוה, על התוכית לעמוד בקריטריוים של כתיבה ותיעוד ברמה טובה,
כמתואר לעיל, אשר משקלם המשותף מגיע עד לכ- 40% ממשקל הפרויקט.

מותר להשתמש בפרויקט בכל מגוון הספריות הסטדרטיות של שפת ,C אבל אין להשתמש בספריות חיצויות אחרות.
מומלץ לעבוד בזוגות. אין לעבוד בצוותים גדולים יותר. פרויקט שיוגש על ידי שלשה או יותר, לא ייבדק ולא יקבל ציון. חובה שסטודטים, הבוחרים להגיש יחד את הפרויקט, יהיו שייכים לאותה קבוצת החיה. הציון יהיה זהה לשי הסטודטים.

מומלץ לקרוא את הגדרת הפרויקט פעם ראשוה ברצף, לקבלת תמוה כללית לגבי הדרש, ורק לאחר מכן לקרוא שוב בצורה מעמיקה יותר.

רקע כללי ומטרת הפרויקט
כידוע, קיימות שפות תכות רבות, ומספר גדול של תוכיות, הכתובות בשפות שוות, עשויות לרוץ באותו מחשב עצמו. כיצד "מכיר" המחשב כל כך הרבה שפות? התשובה פשוטה: המחשב מכיר למעשה שפה אחת בלבד: הוראות ותוים הכתובים בקוד ביארי. קוד זה מאוחסן בגוש בזיכרון, וראה כמו רצף של ספרות ביאריות. יחידת העיבוד המרכזית - היע"מ (CPU) - יודעת לפרק את הרצף הזה לקטעים קטים בעלי משמעות: הוראות, מעים ותוים.

למעשה, זיכרון המחשב כולו הוא אוסף של סיביות, שוהגים לראותן כמקובצות ליחידות בעלות אורך קבוע )בתים, מילים.( לא יתן להבחין, בעין שאיה מיומת, בהבדל פיסי כלשהו בין אותו חלק בזיכרון שבו מצאת תוכית לבין שאר הזיכרון.
יחידת העיבוד המרכזית )היע"מ( יכולה לבצע מגוון פעולות פשוטות, הקראות הוראות מכוה, ולשם כך היא משתמשת באוגרים (registers) הקיימים בתוך היע"מ, ובזיכרון המחשב. דוגמאות: העברת מספר מתא בזיכרון לאוגר ביע"מ או בחזרה, הוספת 1 למספר המצא באוגר,  בדיקה האם מספר המאוחסן באוגר שווה לאפס, חיבור וחיסור בין שי אוגרים, וכד.'
הוראות המכוה ושילובים שלהן הן המרכיבות תוכית כפי שהיא טעוה לזיכרון בזמן ריצתה. כל תוכית מקור )התוכית כפי שכתבה בידי המתכת,( תתורגם בסופו של דבר באמצעות תוכה מיוחדת לצורה סופית זו.

היע"מ יודע לבצע קוד שמצא בפורמט של שפת מכוה. זהו רצף של ביטים, המהווים קידוד ביארי של סדרת הוראות המכוה המרכיבות את התוכית. קוד כזה איו קריא למשתמש, ולכן לא וח לקודד )או לקרוא( תוכיות ישירות בשפת מכוה. שפת אסמבלי language) (assembly היא שפת תכות מאפשרת לייצג את הוראות המכוה בצורה סימבולית קלה ווחה יותר לשימוש. כמובן שיש צורך לתרגם את הייצוג הסימבולי לקוד בשפת מכוה, כדי שהתוכית תוכל לרוץ במחשב. תרגום זה עשה באמצעות כלי שקרא אסמבלר .(assembler)
כידוע, לכל שפת תכות עילית יש מהדר (compiler) , או מפרש ,(interpreter) המתרגם תוכיות מקור לשפת מכוה. האסמבלר משמש בתפקיד דומה עבור שפת אסמבלי.
לכל מודל של יע"מ )כלומר לכל אירגון של מחשב( יש שפת מכוה יעודית משלו, ובהתאם גם שפת אסמבלי יעודית משלו. לפיכך, גם האסמבלר )כלי התרגום( הוא יעודי ושוה לכל יע"מ.

תפקידו של האסמבלר הוא לבות קובץ המכיל קוד מכוה, מקובץ תון של תוכית הכתובה בשפת אסמבלי. זהו השלב הראשון במסלול אותו עוברת התוכית, עד לקבלת קוד המוכן לריצה על חומרת המחשב. השלבים הבאים הם קישור (linkage) וטעיה ,(loading) אך בהם לא עסוק בממ"ן זה.

המשימה בפרויקט זה היא לכתוב אסמבלר )כלומר תוכית המתרגמת לשפת מכוה,( עבור שפת אסמבלי שגדיר כאן במיוחד לצורך הפרויקט.

לתשומת לב: בהסברים הכלליים על אופן עבודת תוכת האסמבלר, תהיה מדי פעם התייחסות גם לעבודת שלבי הקישור והטעיה. התייחסויות אלה ועדו על מת לאפשר לכם להבין את המשך תהליך העיבוד של הפלט של תוכת האסמבלר. אין לטעות: עליכם לכתוב את תוכית האסמבלר בלבד. אין לכתוב את תוכיות הקישור והטעיה!!!
 
המחשב הדמיוי ושפת האסמבלי

גדיר עתה את שפת האסמבלי ואת מודל המחשב הדמיוי, עבור פרויקט זה.

הערה: תאור מודל המחשב להלן הוא חלקי בלבד, ככל שחוץ לביצוע המשימות בפרויקט. "חומרה:"
המחשב בפרויקט מורכב ממעבד )יע"מ,( אוגרים )רגיסטרים,( וזיכרון .RAM חלק מהזיכרון משמש כמחסית .(stack)

למעבד 16 אוגרים כלליים, בשמות: r7….,r15 r6, r5, r4, r3, r2, r1, .r0,
גודלו של כל אוגר הוא 20 סיביות. הסיבית הכי פחות משמעותית תצוין כסיבית מס' ,0 והסיבית המשמעותית ביותר כמס' .19 שמות האוגרים כתבים תמיד עם אות ‘r’ קטה.

כמו כן יש במעבד אוגר בשם PSW word) status ,(program המכיל מספר דגלים המאפייים את מצב הפעילות במעבד בכל רגע תון. ראו בהמשך, בתיאור הוראות המכוה, הסברים לגבי השימוש בדגלים אלו.

גודל הזיכרון הוא 8192 תאים, בכתובות ,8191-0 וכל תא הוא בגודל של 20 סיביות. לתא בזיכרון קרא גם בשם "מילה." הסיביות בכל מילה ממוספרות כמו באוגר.
מחשב זה עובד רק עם מספרים שלמים חיוביים ושליליים. אין תמיכה במספרים ממשייים. האריתמטיקה עשית בשיטת המשלים ל2- complement) .(2’s
כמו כן יש תמיכה בתווים ,(characters) המיוצגים בקוד .ascii מבה הוראת המכוה:
כל הוראת מכוה במודל שלו מורכבת מפעולה ואופרדים. מספר האופרדים הוא בין 0 ל,2- בהתאם לסוג הפעולה. מבחית התפקיד של כל אופרד, בחין בין אופרד מקור (source) ואופרד
.(destination) יעד
כל הוראת מכוה מקודדת למספר מילות זיכרון רצופות, החל ממילה אחת ועד למקסימום שש
מילים, בהתאם לסוג הפעולה )ראו פרטים בהמשך.(
בקובץ הפלט המכיל את קוד המכוה שבוה האסמבלר, כל מילה תקודד "בבסיס מיוחד" )ראו פרטים לגבי קבצי פלט בהמשך.(

בהוראת מכוה ללא אופרדים, המבה של המילה הראשוה )והיחידה( הוא:


19	
18	
17	
16	
15	
14	
13	
12	
11	
10	
9	
8	
7	
6	
5	
4	
3	
2	
1	
0
0	A	R	E	opcode


ואילו בהוראות עם אופרדים המבה של הקידוד יכיל לפחות 2 מילות זיכרון במבה הבא:


19	
18	
17	
16	
15	
14	
13	
12	
11	
10	
9	
8	
7	
6	
5	
4	
3	
2	
1	
0
0	A	R	E	opcode
0	A	R	E	funct	אוגר מקור	מיעון
מקור	אוגר יעד	מיעון
יעד
מילים וספות בהתאם לשיטות המיעון
 
במודל המכוה שלו יש 16 פעולות, בפועל, למרות שיתן לקודד יותר פעולות. כל פעולה מיוצגת בשפת אסמבלי באופן סימבולי על ידי שם-פעולה, ובקוד המכוה על ידי קומביציה ייחודית של ערכי שי שדות במילה הראשוה של ההוראה: קוד-הפעולה ,(opcode) ופוקציה .(funct)
להלן טבלת הפעולות:

opcode
)בבסיס עשרוי(	funct
)בבסיס עשרוי(	שם
הפעולה
0		mov
1		cmp
2	10	add
2	11	sub
4		lea
5	10	clr
5	11	not
5	12	inc
5	13	dec
9	10	jmp
9	11	bne
9	12	jsr
12		red
13		prn
14		rts
15		stop

הערה: שם-הפעולה כתב תמיד באותיות קטות. פרטים על מהות הפעולות השוות יובאו בהמשך.

להלן מפרט השדות בקידוד הראשוה בקוד המכוה של כל הוראה.
שדה :opcode שדה זה מיוצג ב- 16 סיביות, והוא מכיל ביט דולק בודד בהתאם לקוד הפעולה.
למשל אם מדובר על קוד פעולה ,9 אזי סיבית 9 תקבל ערך של .1

סיבית :19 לא בשימוש, ערכה קבוע לאפס.
סיביות :16-18 עבור קידוד הוראות, סיביות אלה מכילות את סיווג הקידוד ) A=Absolute,
E=External (R=Relocatable, לכל מילת קידוד של הוראה יש סיווג, ובהתאם לסיווג הסיבית המתאימה בשדה ARE תקבל ערך .1
סיביות :12-15 שדה זה, הקרא ,funct מתפקד כאשר מדובר בפעולה שקוד-הפעולה (opcode)
שלה משותף לכמה פעולות שוות )כאמור, קודי-פעולה ,2 5 או .(9 השדה funct יכיל ערך ייחודי לכל פעולה מקבוצת הפעולות שיש להן אותו קוד-פעולה. אם קוד-הפעולה משמש לפעולה אחת בלבד, הסיביות של השדה funct יהיו מאופסות.

סיביות :8-11 מכילות את מספרו של אוגר המקור במידה ואופרד המקור הוא אוגר.
אם אין בהוראה אופרד מקור שהוא אוגר, סיביות אלה יהיו מאופסות.

סיביות :6-7 מכילות את מספרה של שיטת המיעון של אופרד המקור.
אם אין בהוראה אופרד מקור, סיביות אלה יהיו מאופסות. מפרט של שיטות המיעון השוות ייתן בהמשך.

סיביות :2-5 מכילות את מספרו של אוגר היעד במידה ואופרד היעד הוא אוגר.
אם אין בהוראה אופרד יעד שהוא אוגר, סיביות אלה יהיו מאופסות.
סיביות :1-0 מכילות את מספרה של שיטת המיעון של אופרד היעד.
אם אין בהוראה אופרד יעד, סיביות אלה יהיו מאופסות.
 
שיטות מיעון:
שיטות מיעון modes) (addressing הן האופים השוים בהם יתן להעביר אופרדים של הוראת
מכוה. בשפת האסמבלי שלו קיימות ארבע שיטות מיעון, המסומות במספרים .0,1,2,3
השימוש בשיטות המיעון מצריך מילות-מידע וספות בקוד המכוה של הוראה, בוסף למילים
הראשוות. קידוד אופרד של הוראה עשוי לייצר מילות זיכרון וספות בהתאם לסוג שיטת המיעון.
 
של אופרד המקור,
 
כאשר בהוראה יש שי אופרדים, קודם יופיעו מילות-המידע הוספות ולאחריהם מילות-המידע הוספות של אופרד היעד.
להלן המפרט של שיטות המיעון.
 

דוגמה	תחביר האופרד באסמבלי	תוכן מילות-המידע הוספות	שיטת המיעון	מספר
mov #-1, r2
בדוגמה זו האופרד הראשון של ההוראה )אופרד המקור( תון בשיטת מיעון מיידי. ההוראה כותבת את הערך -1 אל אוגר .r2	האופרד מתחיל בתו # ולאחריו ובצמוד אליו מופיע  מספר שלם בבסיס עשרוי.	מילת-מידע וספת של ההוראה מכילה את האופרד עצמו, שהוא מספר שלם בשיטת המשלים ל,2- ברוחב של 16 סיביות
מילה זו תסווג מסוג A	מיעון מיידי
(immediate)	0
השורה הבאה מגדירה את התווית :x	האופרד הוא תווית שכבר הוגדרה, או שתוגדר בהמשך הקובץ. ההגדרה עשית על ידי כתיבת התווית בתחילת השורה של החית ‘.data’או ,‘.string’ או בתחילת השורה של הוראה, או באמצעות אופרד של החית .‘.extern’

התווית מייצגת באופן סימבולי כתובת בזיכרון.	2 מילות-מידע וספות של ההוראה יכילו את כתובת האופרד במבה של  כתובת  בסיס  והיסט. כתובת בסיס = הכתובת הקרובה  ביותר לכתובת האופרד, הקטה ממו, ומתחלקת ב.16- למשל, אם כתובת האופרד היא ,36 אזי כתובת הבסיס היא ,32 מאחר ו-  32 הוא המספר הקרוב ביותר ל- 36 שקטן ממו ומתחלק ב.16-

היסט = המרחק מכתובת הבסיס לכתובת האופרד. בדוגמה שיתה בהסבר לכתובת בסיס, ההיסט יהיה .4 מאחר והמרחק )ההיסט(  מ- 32 ל- 36 הוא .4
מילת-המידע הוספת הראשוה תכיל את כתובת הבסיס. ומילת המידע השייה תכיל את ההיסט.

כתובת הבסיס וההיסט מיוצגים כמספר ללא סימן ברוחב של 16 סיביות. והם יסווגו מסוג R
במידה והאופרד הוא תווית חיצוית, כתובת הבסיס וההיסט  יכילו אפסים, וקידודים אלה יסווגו מסוג E במקרה כזה.	מיעון ישיר
(direct)	1
x: .data 23				
ההוראה:
dec x				
מקטיה ב1- את תוכן המילה  שבכתובת  x בזיכרון )ה"משתה" .(x  הכתובת של x מקודדת במילות-המידע הוספות, במבה של כתובת בסיס והיסט.				
דוגמה וספת: ההוראה				
jmp next				
מבצעת  קפיצה  אל השורה בה מוגדרת  התווית next )כלומר  ההוראה הבאה שתתבצע  מצאת בכתובת .(next				
הכתובת next מקודדת במילות-המידע הוספות במבה של כתובת בסיס והיסט.
.				
 
דוגמה	תחביר האופרד באסמבלי	תוכן מילות-המידע הוספות	שיטת המיעון	מספר
השורה הבאה מגדירה את התווית :x
x: .data 23,12,34,50
הפקודה:	האופרד מתחיל בשם של תווית ולאחריה בסוגריים מרובעות, שם של אוגר שמספרו בין 10 ל- 15 בלבד.	בשיטה זו, יש בקידוד ההוראה 2 מילות מידע וספות, המכילות את כתובת התווית בצורת כתובת בסיס והיסט כפי שתואר בשיטת  מיעון מספר .1	מיעון אידקס	2
mov x[r12], r4

בדוגמה  זו  האופרד הראשון  הוא  גישה  לכתובת של X בזיכרון,  והחל משם מתקדמים כמות של מילות זיכרון  וספות לפי הערך שיהיה בזמן ריצה באוגר ,r12 ומה שיש באותה כתובת ישמש  את  המעבד כאופרד המקור. בדוגמה  זו אופרד זו יישמר באוגר r4		מספרו של האוגר שצוין בסוגריים המרובעות, יישמר כפי שמוסבר בשיטת מיעון מספר ,3 בסיביות אוגר המקור/יעד בהתאם לכך אם האופרד הוא אופרד מקור/יעד.		
clr r1
בדוגמה זו, ההוראה clr מאפסת את האוגר .r1

דוגמה וספת:
mov #-1, r2	האופרד הוא שם של אוגר.	אין מילות-מידע וספות בגין
האוגר.
מספרו של האוגר יישמר בסיביות של אוגר המקור/יעד בהתאם לכך אם האופרד הוא אופרד מקור/יעד.	מיעון אוגר ישיר
(register direct)	3
האופרד  השי  של ההוראה )אופרד היעד(  תון בשיטת מיעון אוגר ישיר. ההוראה כותבת את הערך המיידי -1 אל אוגר .r2				
 
מפרט הוראות המכוה:
בתיאור הוראות המכוה שתמש במוח PC )קיצור של Counter” .(“Program
זהו אוגר פימי של המעבד )לא אוגר כללי,( שמכיל בכל רגע תון את כתובת הזיכרון בה מצאת
ההוראה הוכחית שמתבצעת )הכווה תמיד לכתובת המילה הראשוה של ההוראה.(
הוראות המכוה מתחלקות לשלוש קבוצות, לפי מספר האופרדים הדרשים לפעולה.
קבוצת ההוראות הראשוה:
אלו הן הוראות המקבלות שי אופרדים.
ההוראות השייכות לקבוצה זו הן: lea sub, add, cmp, mov,

הסבר הדוגמה	דוגמה	הפעולה המתבצעת	funct	opcode	הוראה
העתק את תוכן המשתה A )המילה שבכתובת A
בזיכרון( אל אוגר .r1	mov A, r1	מבצעת העתקה של תוכן אופרד המקור )האופרד הראשון( אל
אופרד היעד )האופרד השי.(		0	mov
אם תוכן המשתה A זהה לתוכו של אוגר r1 אזי הדגל Z  ")דגל  האפס("  באוגר הסטטוס (PSW) יודלק,  אחרת הדגל יאופס.	cmp A, r1	מבצעת  השוואה  בין  שי האופרדים. ערך  אופרד היעד  )השי( מופחת מערך אופרד המקור  )הראשון,( ללא שמירת תוצאת החיסור. פעולת החיסור מעדכת  דגל בשם Z ")דגל האפס(" באוגר
הסטטוס .(PSW)		1	cmp
אוגר r0 מקבל את תוצאת החיבור של תוכן המשתה A
ותוכו הוכחי של .r0	add A, r0	אופרד היעד )השי( מקבל את תוצאת החיבור של אופרד המקור
)הראשון( והיעד )השי.(	10	2	add
אוגר r1 מקבל את תוצאת החיסור של הקבוע 3 מתוכו
הוכחי של האוגר .r1	sub #3, r1	אופרד היעד )השי( מקבל את תוצאת החיסור של אופרד המקור
)הראשון( מאופרד היעד )השי.(	11	2	sub
המען שמייצגת התווית
HELLO מוצב לאוגר .r1	lea HELLO, r1	lea הוא קיצור )ראשי תיבות( של
זו פעולה .load effective address
מציבה את מען הזיכרון המיוצג על ידי התווית שבאופרד הראשון
)המקור,( אל האופרד השי )היעד.(		4	lea

קבוצת ההוראות השיה:
אלו הן הוראות המקבלות אופרד אחד בלבד. אופן הקידוד של האופרד הוא כמו של אופרד היעד בהוראה עם שי אופרדים. השדה של אופרד המקור )סיביות (3-2 במילה הראשוה בקידוד ההוראה איו בשימוש, ולפיכך יהיו מאופס.
clr, not, inc, dec, jmp, bne, jsr, red, prn :הן זו לקבוצה השייכות ההוראות

הסבר הדוגמה	דוגמה	הפעולה המתבצעת	funct	opcode	הוראה
האוגר r2 מקבל את הערך .0	clr r2	איפוס תוכן האופרד.	10	5	clr
כל ביט באוגר r2 מתהפך.	not r2	היפוך הסיביות באופרד )כל סיבית
שערכה 0 תהפוך ל1- ולהיפך: 1 ל.(0-	11	5	not
תוכן האוגר r2 מוגדל ב- .1	inc r2	הגדלת תוכן האופרד באחד.	12	5	inc
תוכן המשתה Count מוקטן ב- .1	dec Count	הקטת תוכן האופרד באחד.	13	5	dec
PCPC+addressOf(Line)
הכתובת של תווית Line שמרת לתוך מצביע התכית
ולפיכך ההוראה הבאה שתתבצע תהיה במען .Line	jmp Line	קפיצה )הסתעפות( בלתי מותית אל ההוראה שמצאת במען המיוצג על ידי  האופרד.  כלומר,  כתוצאה מביצוע ההוראה, מצביע התוכית  (PC) מקבל את כתובת יעד הקפיצה.	10	9	jmp
 
הסבר הדוגמה	דוגמה	הפעולה המתבצעת	funct	opcode	הוראה
אם ערך הדגל Z באוגר הסטטוס (PSW) הוא ,0 אזי
PC  address(Line)
מצביע התכית יקבל את כתובת התווית ,Line ולפיכך  ההוראה הבאה שתתבצע תהיה במען .Line	bne Line	bne הוא קיצור )ראשי תיבות( של:
זוהי .branch if not equal (to zero)
הוראת הסתעפות מותית. אם ערכו של הדגל Z באוגר הסטטוס (PSW) היו ,0 אזי מצביע התוכית (PC) מקבל את כתובת יעד הקפיצה. כזכור, הדגל Z קבע באמצעות
הוראת .cmp	11	9	bne
push(PC+2)
PC  address(SUBR)
מצביע התכית יקבל את כתובת התווית ,SUBR ולפיכך,  ההוראה  הבאה  שתתבצע תהיה במען .SUBR  כתובת החזרה מהשגרה
שמרת במחסית.	jsr SUBR	קריאה לשגרה )סברוטיה.( כתובת ההוראה שאחרי הוראת jsr הוכחית (PC+2)  דחפת לתוך המחסית שבזיכרון המחשב, ומצביע התוכית  (PC) מקבל את כתובת השגרה. הערה: חזרה מהשגרה מתבצעת באמצעות הוראת ,rts תוך שימוש  בכתובת שבמחסית.	12	9	jsr
קוד הascii- של התו הקרא
מהקלט ייכס לאוגר .r1	red r1	קריאה של תו מהקלט הסטדרטי
(stdin) אל האופרד.		12	red
יודפס לפלט התו )קוד (ascii
המצא באוגר r1	prn r1	הדפסת התו המצא באופרד, אל הפלט הסטדרטי .(stdout)		13	prn

קבוצת ההוראות השלישית:
אלו הן הוראות ללא אופרדים. קידוד ההוראה מורכב ממילה אחת בלבד. השדות של אופרד המקור ושל אופרד היעד )סיביות (3-0 במילה הראשוה של ההוראה אים בשימוש, ולפיכך יהיו מאופסים.
 
.rts, stop
 
ההוראות השייכות לקבוצה זו הן:
 

הסבר הדוגמה	דוגמה	הפעולה המתבצעת	opcode	הוראה
PC  pop()
ההוראה הבאה שתתבצע תהיה זו שאחרי הוראת jsr שקראה לשגרה.	rts	מתבצעת חזרה משיגרה. הערך שבראש המחסית של המחשב מוצא מן המחסית, ומוכס למצביע התוכית .(PC)
הערה: ערך זה כס למחסית בקריאה לשגרה ע"י הוראת .jsr	14	rts
התוכית עוצרת מיידית.	stop	עצירת ריצת התוכית.	15	stop

מבה תכית בשפת אסמבלי:

תכית בשפת אסמבלי בויה ממקרואים וממשפטים .(statements)

מקרואים:
מקרואים הם קטעי קוד הכוללים בתוכם משפטים. בתוכית יתן להגדיר מקרו ולהשתמש בו במקומות שוים בתוכית. השימוש במקרו ממקום מסוים בתוכית יגרום לפרישת המקרו לאותו מקום.

הגדרת מקרו עשית באופן הבא: )בדוגמה שם המקרו הוא (m1

macro m1 inc r2 mov A,r1
endm
 
שימוש במקרו הוא פשוט אזכור שמו. למשל, אם בתוכית במקום כלשהו כתוב:
.
.
.
m1
.
.
m1
.
.
.
בדוגמה זו, השתמשו פעמיים במקרו ,m1 התוכית לאחר פרישת המקרו תיראה כך:

.
.
.
 
inc r2 mov A,r1
.
.
inc r2 mov A,r1
.
.
.
 










התוכית לאחר פרישת המקרו היא התוכית שהאסמבלר אמור לתרגם.
החיות לגבי מקרו:
 
•  אין במערכת הגדרות מקרו מקוות.
•  שם של הוראה או החיה לא יכול להיות שם של מקרו.
•  יתן להיח שלכל שורת מקרו בקוד המקור קיימת סגירה עם שורת endm )אין צורך לבדוק זאת.(
•  הגדרת מקרו תהיה תמיד לפי הקריאה למקרו
•  דרש שהקדם-אסמבלר ייצור קובץ עם הקוד המורחב הכולל פרישה של המקרו )הרחבה של קובץ המקור המתואר בהמשך.( "קובץ המקור המורחב" הוא "קובץ מקור" לאחר פרישת המקרו, לעומת "קובץ מקור ראשוי" שהוא קובץ הקלט למערכת, כולל הגדרת המקרואים.



משפטים:
קובץ מקור בשפת אסמבלי מורכב משורות המכילות משפטים של השפה, כאשר כל משפט מופיע בשורה פרדת. כלומר, ההפרדה בין משפט למשפט בקובץ המקור היה באמצעות התו ‘\n’ )שורה חדשה.(

אורכה של שורה בקובץ המקור הוא 80 תווים לכל היותר )לא כולל התו .(\n יש ארבעה סוגי משפטים )שורות בקובץ המקור( בשפת אסמבלי, והם:
 
הסבר כללי	סוג המשפט
זוהי שורה המכילה אך ורק תווים לבים ,(whitespace) כלומר רק את התווים ’ ‘ ו- ‘\t’ )רווחים וטאבים.( ייתכן ובשורה אין אף תו )למעט התו
,(\n כלומר השורה ריקה.	משפט ריק
זוהי שורה בה התו הראשון היו ‘;’ )קודה פסיק.( על האסמבלר להתעלם לחלוטין משורה זו.	משפט הערה
זהו משפט המחה את האסמבלר מה עליו לעשות כשהוא פועל על תוכית המקור. יש מספר סוגים של משפטי החיה. משפט החיה עשוי לגרום להקצאת זיכרון ואתחול משתים של התוכית, אך הוא איו
מייצר קידוד של הוראות מכוה המיועדות לביצוע בעת ריצת התוכית.	משפט החיה
זהו משפט המייצר קידוד של הוראות מכוה לביצוע בעת ריצת התוכית. המשפט מורכב משם ההוראה )פעולה( שעל המעבד לבצע, והאופרדים
של ההוראה.	משפט הוראה


כעת פרט יותר לגבי סוגי המשפטים השוים.
משפט החיה:

משפט החיה הוא בעל המבה הבא:
בתחילת המשפט יכולה להופיע הגדרה של תווית .(label) לתווית יש תחביר חוקי שיתואר
בהמשך. התווית היא אופציואלית.

לאחר מכן מופיע שם ההחיה. לאחר שם ההחיה יופיעו פרמטרים )מספר הפרמטרים בהתאם להחיה.( שם של החיה מתחיל בתו ‘.’ )קודה( ולאחריו תווים באותיות קטות case) (lower בלבד.

יש ארבעה סוגים )שמות( של משפטי החיה, והם:
‘.data’ חיההה  .1

הפרמטרים של ההחיה ‘.data’ הם מספרים שלמים חוקיים )אחד או יותר( המופרדים על ידי התו ‘,’ )פסיק.( לדוגמה:
.data 7, −57, +17, 9
יש לשים לב שהפסיקים אים חייבים להיות צמודים למספרים. בין מספר לפסיק ובין פסיק למספר יכולים להופיע רווחים וטאבים בכל כמות )או בכלל לא,( אולם הפסיק חייב להופיע בין המספרים. כמו כן, אסור שיופיע יותר מפסיק אחד בין שי מספרים, וגם לא פסיק אחרי המספר האחרון או לפי המספר הראשון.

המשפט ‘.data’ מחה את האסמבלר להקצות מקום בתמות התוים image) ,(data אשר בו
יאוחסו הערכים של הפרמטרים, ולקדם את מוה התוים, בהתאם למספר הערכים. אם בהחית .data מוגדרת תווית, אזי תווית זו מקבלת את ערך מוה התוים )לפי הקידום,( ומוכסת אל טבלת הסמלים. דבר זה מאפשר להתייחס אל מקום מסוים בתמות התוים דרך שם התווית )למעשה, זוהי דרך להגדיר שם של משתה.(

כלומר אם כתוב:
XYZ: .data 7, –57, +17, 9

אזי יוקצו בתמות התוים ארבע מילים רצופות שיכילו את המספרים שמופיעים בהחיה. התווית XYZ מזוהה עם כתובת המילה הראשוה.
אם כתוב בתוכית את ההוראה:
mov XYZ, r1
 
אזי בזמן ריצת התוכית יוכס לאוגר r1 הערך .7
ואילו ההוראה:
lea XYZ, r1

תכיס לאוגר r1 את ערך התווית XYZ )כלומר הכתובת בזיכרון בה מאוחסן הערך .(7
‘.string’ חיההה  .2

להחיה ‘.string’ פרמטר אחד, שהוא מחרוזת חוקית. תווי המחרוזת מקודדים לפי ערכי הascii- המתאימים, ומוכסים אל תמות התוים לפי סדרם, כל תו במילה פרדת. בסוף המחרוזת יתווסף התן ‘\0’ )הערך המספרי ,(0 המסמן את סוף המחרוזת. מוה התוים של האסמבלר יקודם בהתאם לאורך המחרוזת )בתוספת מקום אחד עבור התו המסיים.( אם בשורת ההחיה מוגדרת תווית, אזי תווית זו מקבלת את ערך מוה התוים )לפי הקידום( ומוכסת אל טבלת הסמלים, בדומה כפי שעשה עבור ‘.data’ )כלומר ערך התווית יהיה הכתובת בזיכרון שבה מתחילה המחרוזת.(

לדוגמה, ההחיה:
STR: .string “abcdef”

מקצה בתמות התוים רצף של 7 מילים, ומאתחלת את המילים לקודי הascii- של התווים לפי הסדר במחרוזת, ולאחריהם הערך 0 לסימון סוף מחרוזת. התווית STR מזוהה עם כתובת התחלת המחרוזת.

‘.entry’ חיההה	.3

להחיה ‘.entry’ פרמטר אחד, והוא שם של תווית המוגדרת בקובץ המקור הוכחי )כלומר תווית שמקבלת את ערכה בקובץ זה.( מטרת ההחיה .entry היא לאפיין את התווית הזו באופן שיאפשר לקוד אסמבלי המצא בקבצי מקור אחרים להשתמש בה )כאופרד של הוראה.(

לדוגמה, השורות:
.entry HELLO
HELLO:	add #1, r1
מודיעות לאסמבלר שאפשר להתייחס בקובץ אחר לתווית HELLO המוגדרת בקובץ הוכחי.
לתשומת לב: תווית המוגדרת בתחילת שורת .entry היה חסרת משמעות והאסמבלר מתעלם מתווית זו )אפשר שהאסמבלר יוציא הודעת אזהרה.(
‘.extern’ חיההה	.4
להחיה ‘.extern’ פרמטר אחד, והוא שם של תווית שאיה מוגדרת בקובץ המקור הוכחי. מטרת ההוראה היא להודיע לאסמבלר כי התווית מוגדרת בקובץ מקור אחר, וכי קוד האסמבלי בקובץ הוכחי עושה בתווית שימוש.

שים לב כי החיה זו תואמת להחית ‘.entry’ המופיעה בקובץ בו מוגדרת התווית. בשלב הקישור תתבצע התאמה בין ערך התווית, כפי שקבע בקוד המכוה של הקובץ שהגדיר את התווית, לבין קידוד ההוראות המשתמשות בתווית בקבצים אחרים )שלב הקישור איו רלווטי לממ"ן זה.(

לדוגמה, משפט ההחיה ‘.extern’ התואם למשפט ההחיה ‘.entry’ מהדוגמה הקודמת יהיה:

.extern HELLO
הערה: לא יתן להגדיר באותו הקובץ את אותה התווית גם כentry- וגם כextern- )בדוגמאות
לעיל, התווית .(HELLO
 
לתשומת לב: תווית המוגדרת בתחילת שורת .extern היה חסרת משמעות והאסמבלר מתעלם מתווית זו )אפשר שהאסמבלר יוציא הודעת אזהרה.(
משפט הוראה:
משפט הוראה מורכב מהחלקים הבאים:

.1 תווית אופציולית. .2 שם הפעולה.
.3  אופרדים, בהתאם לסוג הפעולה )בין 0 ל2- אופרדים.(
אם מוגדרת תווית בשורת ההוראה, אזי היא תוכס אל טבלת הסמלים. ערך התווית יהיה מען המילה הראשוה של ההוראה בתוך תמות הקוד שבוה האסמבלר.


שם הפעולה תמיד באותיות קטות case) ,(lower והוא אחת מ- 16 הפעולות שפורטו לעיל.
לאחר שם הפעולה יופיעו האופרדים, בהתאם לסוג הפעולה. יש להפריד בין שם-הפעולה לבין האופרד הראשון באמצעות רווחים ו/או טאבים )אחד או יותר.(
כאשר יש שי אופרדים, האופרדים מופרדים זה מזה בתו ‘,’ )פסיק.( בדומה להחיה ,‘.data’ לא חייבת להיות הצמדה של האופרדים לפסיק. כל כמות של רווחים ו/או טאבים משי צידי הפסיק היא חוקית.
למשפט הוראה עם שי אופרדים המבה הבא:
label: opcode source-operand, target-operand
לדוגמה:
HELLO: add r7, B

למשפט הוראה עם אופרד אחד המבה הבא:

label: opcode target-operand
לדוגמה:
HELLO: bne XYZ

 

label: opcode

END: stop
 
למשפט הוראה ללא אופרדים המבה הבא: לדוגמה:
אפיון השדות במשפטים של שפת האסמבלי

תווית:
 
תווית היא סמל שמוגדר בתחילת משפט הוראה’ או בתחילת החיית .data או .string
תווית חוקית מתחילה באות אלפביתית )גדולה או קטה,( ולאחריה סדרה כלשהי של אותיות אלפביתיות )גדולות או קטות( ו/או ספרות. האורך המקסימלי של תווית הוא 31 תווים.
הגדרה של תווית מסתיימת בתו ‘:’ )קודתיים.( תו זה איו מהווה חלק מהתווית, אלא רק סימן המציין את סוף ההגדרה. התו ‘:’ חייב להיות צמוד לתווית )ללא רווחים.(

אסור שאותה תווית תוגדר יותר מפעם אחת )כמובן בשורות שוות.( אותיות קטות וגדולות חשבות שוות זו מזו.
לדוגמה, התוויות המוגדרות להלן הן תוויות חוקיות.
 
hEllo:
x:
He78902:
לתשומת לב: מילים שמורות של שפת האסמבלי )כלומר שם של פעולה או החיה, או שם של אוגר( אין יכולות לשמש גם כשם של תווית. לדוגמה: הסמלים ,add r3 לא יכולים לשמש כתוויות, אבל הסמלים ,Add ,r19 R3 הם תוויות חוקיות.
התווית מקבלת את ערכה בהתאם להקשר בו היא מוגדרת. תווית המוגדרת בהחיות .data או
,.string תקבל את ערך מוה התוים counter) (data הוכחי, בעוד שתווית המוגדרת בשורת הוראה תקבל את ערך מוה ההוראות counter) (instruction הוכחי.
לתשומת לב: מותר במשפט הוראה להשתמש באופרד שהוא סמל שאיו מוגדר כתווית בקובץ
הוכחי, כל עוד הסמל מאופיין כחיצוי )באמצעות החיית .extern כלשהי בקובץ הוכחי.(

מספר:
מספר חוקי מתחיל בסימן אופציולי: ‘–‘ או ‘+’ ולאחריו סדרה של ספרות בבסיס עשרוי.
 
הם מספרים חוקיים. אין תמיכה בשפת האסמבלי שלו בייצוג בבסיס
 
+123 ,–5 ,76
 
לדוגמה:
 
אחר מאשר עשרוי, ואין תמיכה במספרים שאים שלמים. מחרוזת:
מחרוזת חוקית היא סדרת תווי ascii ראים )שיתים להדפסה,( המוקפים במרכאות כפולות )המרכאות אין חשבות חלק מהמחרוזת.( דוגמה למחרוזת חוקית: world” .“hello
סימון המילים בקוד המכוה באמצעות המאפיין “A,R,E”
האסמבלר בוה מלכתחילה קוד מכוה שמיועד לטעיה החל מכתובת .100 אולם, לא בכל פעם שהקוד ייטען לזיכרון לצורך הרצה, מובטח שאפשר יהיה לטעון אותו החל מכתובת .100 במקרה
כזה, קוד המכוה התון איו מתאים ויש צורך לתקן אותו. לדוגמה, מילת-המידע של אופרד
בשיטת מיעון ישיר לא תהיה כוה, כי הכתובת השתתה.

הרעיון הוא להכיס תיקוים קודתיים בקוד המכוה בכל פעם שייטען לזיכרון לצורך הרצה. כך אפשר יהיה לטעון את הקוד בכל פעם למקום אחר, בלי צורך לחזור על תהליך האסמבלי. תיקוים כאלה עשים בשלב הקישור והטעיה של הקוד )או לא מטפלים בכך בממ"ן זה,( אולם על האסמבלר להוסיף מידע בקוד המכוה שיאפשר לזהות את הקודות בקוד בהן דרש תיקון.

לצד כל מילה בקוד המכוה, האסמבלר מוסיף מאפיין שקרא .“A,R,E” לכל מילה בקוד, מוצמד שדה המכיל את אחת האותיות A או R או .E
•  האות A )קיצור של (Absolute באה לציין שתוכן המילה איו תלוי במקום בזיכרון בו ייטען
בפועל קוד המכוה של התוכית בעת ביצועה )למשל, 2 המילים המכילים את קוד ההוראה
ואת שיטות המיעון, או מילת-מידע המכילה אופרד מיידי.(
•  האות R )קיצור של (Relocatable באה לציין שתוכן המילה תלוי במקום בזיכרון בו ייטען בפועל קוד המכוה של התוכית בעת ביצועה )למשל, מילות-מידע המכילות כתובת של תווית בצורת כתובת בסיס והיסט.(
•  האות E )קיצור של (External באה לציין שתוכן המילה תלוי בערכו של סמל שאיו מוגדר בקובץ המקור הוכחי )למשל, מילת-מידע המכילה ערך של סמל המופיע בהחיית .(.extern

שים לב כי רוב המילים בקוד המכוה מאופייות על ידי האות .A למעשה, רק מילות-המידע הוספות של שיטת מיעון ישיר ושל שיטת מיעון אידקס מאופייות על ידי האות R או E )תלוי אם האופרד בקוד האסמבלי הוא תווית מקומית או סמל חיצוי.(
 
כאשר האסמבלר מקבל כקלט תוכית בשפת אסמבלי, עליו לטפל תחילה בפרישת המקרואים, ורק לאחר מכן לעבור על התוכית אליה פרשו המקרואים. כלומר, פרישת המקרואים תעשה בשלב "קדם אסמבלר," לפי שלב האסמבלר )המתואר בהמשך( .
אם התכית איה מכילה מקרו, תוכית הפרישה תהיה זהה לתכית המקור.

דוגמה לשלב קדם אסמבלר. האסמבלר מקבל את התוכית הבאה בשפת אסמבלי:

; file ps.as
.entry LIST
.extern W
MAIN:	add	r3, LIST
LOOP:	prn	#48
macro m1
inc r6 mov r3, W
endm
lea	STR, r6 m1
sub	r1, r4
bne	END
cmp	val1, #-6
bne	END[r15]
dec	K
.entry MAIN
sub	LOOP[r10] ,r14
END:	stop
STR:	.string	“abcd”
LIST:	.data	6, -9
.data	-100
.entry K
K:	.data	31
.extern val1



תחילה האסמבלר עובר על התוכית ופורש את כל המקרואים הקיימים בה. רק אם תהליך זה מסתיים
בהצלחה, יתן לעבור לשלב הבא. בדוגמה זו, התוכית לאחר פרישת המקרו תיראה כך:
 
; file ps.am
.entry LIST
.extern W	
MAIN:	add	r3, LIST
LOOP:







.entry MAIN
END:	prn lea inc mov sub bne cmp bne dec
sub stop	#48
STR, r6
r6
r3, W
r1, r4 END
val1, #-6 END[r15] K
LOOP[r10] ,r14
STR:	.string	“abcd”
LIST:	.data	6, -9
.entry K	.data	-100
K:
.extern val1	.data	31
		קוד התכית, לאחר הפרישה, ישמר בקובץ חדש, כפי שיוסבר בהמשך.
		אלגוריתם שלדי של קדם האסמבלר
ציג להלן אלגוריתם שלדי לתהליך קדם האסמבלר. לתשומת לב: אין חובה להשתמש דווקא באלגוריתם זה:
.1  קרא את השורה הבאה מקובץ המקור. אם גמר הקובץ, עבור ל- 9 )סיום.(
.2 האם השדה הראשון הוא שם מקרו המופיע בטבלת המקרו )כגון ?(m1 אם כן, החלף את שם המקרו והעתק במקומו את כל השורות המתאימות מהטבלה לקובץ, חזור ל .1 אחרת, המשך.
.3 האם השדה הראשון הוא " macro " )התחלת הגדרת מקרו?( אם לא, עבור ל- .6 .4 הדלק דגל "יש ."macro
.5 )קיימת הגדרת מקרו( הכס לטבלת שורות מקרו את שם המקרו )לדוגמה m1 .( .6  קרא את השורה הבאה מקובץ המקור. אם גמר קובץ המקור, עבור ל- 9 )סיום.(
אם דגל "יש "macro דולק ולא זוהתה תווית endm הכס את השורה לטבלת המקרו ומחק את השורה ה"ל מהקובץ. אחרת )לא מקרו( חזור ל .1
.7  האם זוהתה תווית ?endm אם כן, מחק את התווית מהקובץ והמשך. אם לא, חזור ל- 6
.8 כבה דגל "יש ."macro חזור ל- .1 )סיום שמירת הגדרת מקרו( .9 סיום: שמירת קובץ מקרו פרוש.

כעת לאחר פרישת כל המקרואים יתן לעבור לשלב התרגום לקוד מכוה, שלב האסמבלר.


אסמבלר עם שי מעברים

במעבר הראשון של האסמבלר, יש לזהות את הסמלים )תוויות( המופיעים בתוכית, ולתת לכל סמל ערך מספרי שהוא המען בזיכרון שהסמל מייצג. במעבר השי, באמצעות ערכי הסמלים, וכן קודי-הפעולה ומספרי האוגרים, בוים את קוד המכוה.
 
קוד המכוה של התוכית )הוראות ותוים( בה כך שיתאים לטעיה בזיכרון החל ממען 100 )עשרוי.( התרגום של תוכית המקור שבדוגמה לקוד ביארי מוצג להלן:
Address (decimal)	Source Code	Machine Code (binary)
		19	..	..	..	..	..	..	..	..	..	9	8	7	6	5	4	3	2	1	0
0100	MAIN: add r3, LIST	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0101		0	1	0	0	1	0	1	0	0	0	1	1	1	1	0	0	0	0	0	1
0102		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	1	0	0	0	0
0103		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
0104	LOOP: prn #48	0	1	0	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0
0105		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0106		0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0
0107	lea STR, r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0
0108		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	1	1	0	1	1
0109		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0110		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	1
0111	inc r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0112		0	1	0	0	1	1	0	0	0	0	0	0	0	0	0	1	1	0	1	1
0113	mov r3, W	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1
0114		0	1	0	0	0	0	0	0	0	0	1	1	1	1	0	0	0	0	0	1
0115		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0116		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0117	sub r1, r4	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0118		0	1	0	0	1	0	1	1	0	0	0	1	1	1	0	1	0	0	1	1
0119	bne END	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0120		0	1	0	0	1	0	1	1	0	0	0	0	0	0	0	0	0	0	0	1
0121		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0122		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0
0123	cmp val1, #-6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
0124		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0
0125		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0126		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0127		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	1	0	1	0
0128	bne END[r15]	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0129		0	1	0	0	1	0	1	1	0	0	0	0	0	0	1	1	1	1	1	0
0130		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0131		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0
0132	dec K	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0133		0	1	0	0	1	1	0	1	0	0	0	0	0	0	0	0	0	0	0	1
0134		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	1	0	0	0	0
0135		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	1
0136	sub LOOP[r10],r14	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0137		0	1	0	0	1	0	1	1	1	0	1	0	1	0	1	1	1	0	1	1
0138		0	0	1	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0	0
0139		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0
0140	END: stop	0	1	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0141	STR: .string “abcd”	0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0	1
0142		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	0
0143		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	1
0144		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	1	0	0
0145		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0146	LIST: .data 6, -9	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0
0147		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	0	1	1	1
0148	.data -100	0	1	0	0	1	1	1	1	1	1	1	1	1	0	0	1	1	1	0	0
0149	K:	.data 31	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	1	1	1
 
האסמבלר מחזיק טבלה שבה רשומים כל שמות הפעולה של ההוראות והקודים הביאריים funct) (opcode, המתאימים להם, ולכן שמות הפעולות יתים להמרה לביארי בקלות. כאשר קרא שם פעולה, אפשר פשוט לעיין בטבלה ולמצוא את הקידוד הביארי.

כדי לבצע המרה לביארי של אופרדים שכתובים בשיטות מיעון המשתמשות בסמלים )תוויות,( יש צורך לבות טבלה המכילה את ערכי כל הסמלים. אולם בהבדל מהקודים של הפעולות, הידועים מראש, הרי המעים בזיכרון עבור הסמלים שבשימוש התוכית אים ידועים, עד אשר תוכית המקור סרקה כולה ותגלו כל הגדרות הסמלים.
למשל, בקוד לעיל, האסמבלר איו יכול לדעת שהסמל END אמור להיות משויך למען 140 )עשרוי,( ושהסמל K אמור להיות משויך למען ,149 אלא רק לאחר שקראו כל שורות התוכית.

לכן מפרידים את הטיפול של האסמבלר בסמלים לשי שלבים. בשלב הראשון בוים טבלה של כל הסמלים, עם הערכים המספריים המשויכים להם, ובשלב השי מחליפים את כל הסמלים, המופיעים באופרדים של הוראות התוכית, בערכיהם המספריים. הביצוע של שי שלבים אלה כרוך בשתי סריקות )הקראות "מעברים(" של קובץ המקור.

במעבר הראשון בית טבלת סמלים בזיכרון, ובה לכל סמל שבתוכית המקור משויך ערך מספרי, שהוא מען בזיכרון.

במעבר השי עשית ההמרה של קוד המקור לקוד מכוה. בתחילת המעבר השי צריכים הערכים של כל הסמלים להיות כבר ידועים
עבור הדוגמה, טבלת הסמלים תוה להלן. לכל סמל יש בטבלה גם מאפייים (attributes) שיוסברו
בהמשך. אין חשיבות לסדר השורות בטבלה )כאן הטבלה לפי הסדר בו הוגדרו הסמלים בתכית.(

Symbol	Value (decimal)	Base address	offset	Attributes
W	0	0	0	external
MAIN	100	96	4	code, entry
LOOP	104	96	8	code
END	140	128	12	code
STR	141	128	13	data
LIST	146	144	2	data, entry
K	149	144	5	data, entry
val1	0	0	0	external

לתשומת לב: תפקיד האסמבלר, על שי המעברים שלו, לתרגם קובץ מקור לקוד בשפת מכוה. בגמר פעולת האסמבלר, התוכית טרם מוכה לטעיה לזיכרון לצורך ביצוע. קוד המכוה חייב לעבור לשלבי הקישור/טעיה, ורק לאחר מכן לשלב הביצוע )שלבים אלה אים חלק מהממ"ן.(

המעבר הראשון
במעבר הראשון דרשים כללים כדי לקבוע איזה מען ישויך לכל סמל. העיקרון הבסיסי הוא לספור את המקומות בזיכרון, אותם תופסות ההוראות. אם כל הוראה תיטען בזיכרון למקום העוקב להוראה הקודמת, תציין ספירה כזאת את מען ההוראה הבאה. הספירה עשית על ידי האסמבלר ומוחזקת במוה ההוראות (IC) . ערכו ההתחלתי של IC הוא 100 )עשרוי,( ולכן קוד המכוה של ההוראה הראשוה בה כך שייטען לזיכרון החל ממען .100 הIC- מתעדכן בכל שורת הוראה המקצה מקום בזיכרון. לאחר שהאסמבלר קובע מהו אורך ההוראה, הIC- מוגדל במספר התאים )מילים( התפסים על ידי ההוראה, וכך הוא מצביע על התא הפוי הבא.

כאמור, כדי לקודד את ההוראות בשפת מכוה, מחזיק האסמבלר טבלה, שיש בה קידוד מתאים לכל שם פעולה. בזמן התרגום מחליף האסמבלר כל שם פעולה בקידוד שלה. כמו כן, כל אופרד מוחלף בקידוד מתאים, אך פעולת החלפה זו איה כה פשוטה. ההוראות משתמשות בשיטות מיעון מגווות לאופרדים. אותה פעולה יכולה לקבל משמעויות שוות, בכל אחת משיטות המיעון, ולכן יתאימו לה קידודים שוים לפי שיטות המיעון. לדוגמה, פעולת ההזזה mov יכולה להתייחס
 
להעתקת תוכן תא זיכרון לאוגר, או להעתקת תוכן אוגר לאוגר אחר, וכן הלאה. לכל אפשרות כזאת של mov עשוי להתאים קידוד שוה.
על האסמבלר לסרוק את שורת ההוראה בשלמותה, ולהחליט לגבי הקידוד לפי האופרדים. בדרך כלל מתחלק הקידוד לשדה של שם הפעולה, ושדות וספים המכילים מידע לגבי שיטות המיעון. כל השדות ביחד דורשים מילה אחת או יותר בקוד המכוה.
כאשר תקל האסמבלר בתווית המופיעה בתחילת השורה, הוא יודע שלפיו הגדרה של תווית, ואז הוא משייך לה מען – תוכו הוכחי של ה.IC- כך מקבלות כל התוויות את מעיהן בעת ההגדרה. תוויות אלה מוכסות לטבלת הסמלים, המכילה בוסף לשם התווית גם את המען ומאפייים וספים. כאשר תהיה התייחסות לתווית באופרד של הוראה כלשהי, יוכל האסמבלר לשלוף את המען המתאים מטבלת הסמלים.
הוראה יכולה להתייחס גם לסמל שטרם הוגדר עד כה בתוכית, אלא יוגדר רק בהמשך התוכית. להלן, לדוגמה, הוראת הסתעפות למען שמוגדר על ידי התווית A שמופיעה רק בהמשך הקוד:
bne  A
.
.
.
A:	……

כאשר מגיע האסמבלר לשורת ההסתעפות A) ,(bne הוא טרם תקל בהגדרת התווית A וכמובן לא יודע את המען המשויך לתווית. לכן האסמבלר לא יכול לבות את הקידוד הביארי של האופרד .A ראה בהמשך כיצד פתרת בעיה זו.

בכל מקרה, תמיד אפשר לבות במעבר הראשון את הקידוד הביארי המלא של המילה הראשוה של כל הוראה, את הקידוד הביארי של מילת-המידע הוספת של אופרד מיידי, או אוגר, וכן את הקידוד הביארי של כל התוים )המתקבלים מההחיות ,.data .(.string

המעבר השי
ראיו שבמעבר הראשון, האסמבלר איו יכול לבות את קוד המכוה של אופרדים המשתמשים בסמלים שעדיין לא הוגדרו. רק לאחר שהאסמבלר עבר על כל התוכית, כך שכל הסמלים כסו כבר לטבלת הסמלים, יכול האסמבלר להשלים את קוד המכוה של כל האופרדים.
לשם כך מבצע האסמבלר מעבר וסף )מעבר שי( על כל קובץ המקור, ומעדכן את קוד המכוה של האופרדים המשתמשים בסמלים, באמצעות ערכי הסמלים מטבלת הסמלים.
בסוף המעבר השי, תהיה התוכית מתורגמת בשלמותה לקוד מכוה.


הפרדת הוראות ותוים

בתוכית מבחיים בשי סוגים של תוכן: הוראות ותוים. יש לארגן את קוד המכוה כך שתהיה הפרדה בין התוים וההוראות. הפרדת ההוראות והתוים לקטעים שוים בזיכרון היא שיטה עדיפה על פי הצמדה של הגדרות התוים להוראות המשתמשות בהן.
אחת הסכות הטמוות באי הפרדת ההוראות מהתוים היא, שלפעמים עלול המעבד, בעקבות שגיאה לוגית בתוכית, לסות "לבצע" את התוים כאילו היו הוראות חוקיות. למשל, שגיאה שיכולה לגרום תופעה כזו היא הסתעפות לא כוה. התוכית כמובן לא תעבוד כון, אך לרוב הזק הוא יותר חמור, כי וצרת חריגת חומרה ברגע שהמעבד מבצע פעולה שאיה חוקית.
האסמבלר שלו חייב להפריד, בקוד המכוה שהוא מיצר, בין קטע התוים לקטע ההוראות. כלומר בקובץ הפלט )בקוד המכוה( תהיה הפרדה של הוראות ותוים לשי קטעים פרדים, אם כי בקובץ הקלט אין חובה שתהיה הפרדה כזו. בהמשך מתואר אלגוריתם של האסמבלר, ובו פרטים כיצד לבצע את ההפרדה.
 
גילוי שגיאות בתוכית המקור
כפי שהוסבר למעלה, החת המטלה היא שאין שגיאות בהגדרות המקרו, ולכן שלב קדם האסמבלר איו מכיל שלב גילוי שגיאות, לעומת זאת האסמבלר אמור לגלות ולדווח על שגיאות בתחביר של תוכית המקור, כגון פעולה שאיה קיימת, מספר אופרדים שגוי, סוג אופרד שאיו מתאים לפעולה, שם אוגר לא קיים, ועוד שגיאות אחרות. כמו כן מוודא האסמבלר שכל סמל מוגדר פעם אחת בדיוק.

מכאן, שכל שגיאה המתגלה על ידי האסמבלר גרמת )בדרך כלל( על ידי שורת קלט מסוימת.

לדוגמה, אם מופיעים שי אופרדים בהוראה שאמור להיות בה רק אופרד יחיד, האסמבלר ייתן הודעת שגיאה בוסח "יותר מדי אופרדים."

הערה: אם יש שגיאה בקוד האסמבלי בגוף מקרו, הרי שגיאה זו יכולה להופיע ולהתגלות שוב ושוב, בכל מקום בו פרש המקרו. שים לב שכאשר האסמבלר בודק שגיאות, כבר לא יתן לזהות שזה קוד שפרש ממקרו, כך שלא יתן לחסוך גילויי שגיאה כפולים.
האסמבלר ידפיס את הודעות השגיאה אל הפלט הסטדרטי .stdout בכל הודעת שגיאה יש לציין גם את מספר השורה בקובץ המקור בה זוהתה השגיאה )מיין השורות בקובץ מתחיל ב.(1-
לתשומת לב: האסמבלר איו עוצר את פעולתו אחרי שמצאה השגיאה הראשוה, אלא ממשיך לעבור על הקלט כדי לגלות שגיאות וספות, ככל שישן. כמובן שאין כל טעם לייצר את קבצי הפלט אם תגלו שגיאות )ממילא אי אפשר להשלים את קוד המכוה.(

הטבלה הבאה מפרטת מהן של שיטות המיעון החוקיות, עבור אופרד המקור ואופרד היעד של ההוראות השוות הקיימות בשפה התוה:

שיטות מיעון חוקיות
עבור אופרד היעד	שיטות מיעון חוקיות
עבור אופרד המקור	שם ההוראה	funct	opcode
1,2,3	0,1,2,3	mov		0
0,1,2,3	0,1,2,3	cmp		1
1,2,3	0,1,2,3	add	10	2
1,2,3	0,1,2,3	sub	11	2
1,2,3	1,2	lea		4
1,2,3	אין אופרד מקור	clr	10	5
1,2,3	אין אופרד מקור	not	11	5
1,2,3	אין אופרד מקור	inc	12	5
1,2,3	אין אופרד מקור	dec	13	5
1,2	אין אופרד מקור	jmp	10	9
1,2	אין אופרד מקור	bne	11	9
1,2	אין אופרד מקור	jsr	12	9
1,2,3	אין אופרד מקור	red		12
0,1,2,3	אין אופרד מקור	prn		13
אין אופרד יעד	אין אופרד מקור	rts		14
אין אופרד יעד	אין אופרד מקור	stop		15

תהליך העבודה של האסמבלר

תאר כעת את אופן העבודה של האסמבלר. בהמשך, יוצג אלגוריתם שלדי למעבר ראשון ושי.
האסמבלר מתחזק' שי מערכים, שייקראו להלן תמות ההוראות (code) ותמות התוים .(data) מערכים אלו ותים למעשה תמוה של זיכרון המכוה )כל איבר במערך הוא בגודל מילה של המכוה, כלומר 24 סיביות.( במערך ההוראות בוה האסמבלר את הקידוד של הוראות המכוה שקראו במהלך המעבר על קובץ המקור. במערך התוים מכיס האסמבלר את קידוד התוים שקראו מקובץ המקור )שורות החיה מסוג ‘.data’ ו- .(‘.string’
 
האסמבלר משתמש בשי מוים, שקראים IC )מוה ההוראות - ,(Instruction-Counter ו- DC )מוה התוים - .(Data-Counter מוים אלו מצביעים על המקום הבא הפוי במערך ההוראות ובמערך התוים, בהתאמה. בכל פעם כשמתחיל האסמבלר לעבור על קובץ מקור, המוה IC
 
הערך ההתחלתי IC=100 קבע
 
מקבל ערך התחלתי ,100 והמוה DC מקבל ערך התחלתי .0
 
כדי שקוד המכוה של התוכית יתאים לטעיה לזיכרון )לצורך ריצה( החל מכתובת .100
בוסף, מתחזק האסמבלר טבלה, אשר בה אספות כל התוויות בהן תקל האסמבלר במהלך המעבר על קובץ המקור. לטבלה זו קוראים טבלת-הסמלים .(symbol-table) לכל סמל שמרים בטבלה שם הסמל, ערכו המספרי, ומאפייים וספים )אחד או יותר,( כגון המיקום בתמות הזיכרון data) או ,(code וסוג הראות של הסמל external) או .(entry
במעבר הראשון האסמבלר בוה את טבלת הסמלים ואת השלד של תמות הזיכרון )הוראות ותוים.( האסמבלר קורא את קובץ המקור שורה אחר שורה, ופועל בהתאם לסוג השורה )הוראה, החיה,
או שורה ריקה/הערה.(
.1 שורה ריקה או שורת הערה: האסמבלר מתעלם מהשורה ועובר לשורה הבאה. .2 שורת הוראה:
האסמבלר מתח את השורה ומפעח מהי ההוראה, ומהן שיטות המיעון של האופרדים. מספר האופרדים קבע בהתאם להוראה שמצאה. שיטות המיעון קבעות בהתאם לתחביר של כל אופרד, כפי שהוסבר לעיל במפרט שיטות המיעון. למשל, התו # מציין מיעון מידי, תווית מציית מיעון ישיר, שם של אוגר מציין מיעון אוגר ישיר, וכד.'

אם האסמבלר מוצא בשורת ההוראה גם הגדרה של תווית, אזי התווית )הסמל( המוגדרת מוכסת לטבלת הסמלים. ערך הסמל בטבלה הוא ,IC והמאפיין הוא .code

כעת האסמבלר קובע לכל אופרד את ערכו באופן הבא:

•  אם זה אוגר – האופרד הוא מספר האוגר.
•  אם זו תווית )מיעון ישיר( – האופרד הוא ערך התווית כפי שמופיע בטבלת הסמלים )ייתכן והסמל טרם מצא בטבלת הסמלים, במידה והוא יוגדר רק בהמשך התוכית.(
•  אם זה התו # ואחריו מספר )מיעון מידי( – האופרד הוא המספר עצמו.
•  אם זו שיטת מיעון אחרת – ערכו של האופרד קבע לפי המפרט של שיטת המיעון )ראו תאור שיטות המיעון לעיל(

האסמבלר מכיס למערך ההוראות, בכיסה עליה מצביע מוה ההוראות ,IC את הקוד הביארי המלא של המילה הראשוה של ההוראה )בפורמט קידוד כפי שתואר קודם.( מילה זו מכילה את קוד הפעולה וה,funct- ואת מספרי שיטות המיעון של אופרד המקור והיעד.ה- IC מקודם ב.1-
זכור שכאשר יש רק אופרד אחד )כלומר אין אופרד מקור,( הסיביות של שיטת המיעון של אופרד המקור יכילו .0 בדומה, אם זוהי הוראה ללא אופרדים stop) ,(rts, אזי הסיביות של שיטות המיעון של שי האופרדים יכילו .0

אם זוהי הוראה עם אופרדים )אחד או שיים,( האסמבלר "משריין" מקום במערך ההוראות עבור מילות-המידע הוספות הדרשות בהוראה זו, ככל שדרשות, ומקדם את IC בהתאם. כאשר אופרד הוא בשיטת מיעון מיידי או אוגר ישיר, האסמבלר מקודד גם את המילה הוספת המתאימה במערך ההוראות. ואילו בשיטת מיעון ישיר או יחסי, מילת המידע הוספת במערך ההוראות שארת ללא קידוד בשלב זה.

.3  שורת החיה:
כאשר האסמבלר קורא בקובץ המקור שורת החיה, הוא פועל בהתאם לסוג ההחיה, באופן הבא:
 
‘.data’ .I
האסמבלר קורא את רשימת המספרים, המופיעה לאחר ,‘.data’ מכיס כל מספר אל מערך התוים )בקידוד ביארי,( ומקדם את מצביע התוים DC ב1- עבור כל מספר שהוכס.

אם בשורה ‘.data’ מוגדרת גם תווית, אזי התווית מוכסת לטבלת הסמלים. ערך התווית הוא ערך מוה התוים DC שלפי הכסת המספרים למערך. המאפיין של התווית הוא .data

‘.string’ .II
הטיפול ב‘.string’- דומה ל- ,‘.data’ אלא שקודי הascii- של התווים הם אלו המוכסים אל מערך התוים )כל תו במילה פרדת.( לבסוף מוכס למערך התוים הערך 0 )המציין סוף מחרוזת.( המוה DC מקודם באורך המחרוזת + 1 )גם התו המסיים את המחרוזת תופס מקום.(

הטיפול בתווית המוגדרת בהחיה ‘.string’ זהה לטיפול העשה בהחיה .‘.data’
‘.entry’ .III
זוהי החיה לאסמבלר לאפיין את התווית התוה כאופרד כentry- בטבלת הסמלים. בעת הפקת קבצי הפלט )ראו בהמשך,( התווית תירשם בקובץ ה.entries-
לתשומת לב: זה לא חשב כשגיאה אם בקובץ המקור מופיעה יותר מהחיית .entry אחת עם אותה תווית כאופרד. המופעים הוספים אים מוסיפים דבר, אך גם אים מפריעים.
‘.extern’ .IV
זוהי הצהרה על סמל )תווית( המוגדר בקובץ מקור אחר, והקובץ הוכחי עושה בו שימוש. האסמבלר מכיס את הסמל המופיע כאופרד לטבלת הסמלים, עם הערך 0 )הערך האמיתי לא ידוע, וייקבע רק בשלב הקישור,( ועם המאפיין .external לא ידוע באיזה קובץ מצאת הגדרת הסמל, ואין זה רלווטי עבור האסמבלר.
לתשומת לב: זה לא חשב כשגיאה אם בקובץ המקור מופיעה יותר מהחיית .extern אחת עם אותה תווית כאופרד. המופעים הוספים אים מוסיפים דבר, אך גם אים מפריעים.

לתשומת לב: באופרד של הוראה או של החית ,.entry מותר להשתמש בסמל אשר יוגדר בהמשך הקובץ )אם באופן ישיר על ידי הגדרת תווית, ואם באופן עקיף על ידי החית .(.extern

בסוף המעבר הראשון, האסמבלר מעדכן בטבלת הסמלים כל סמל המאופיין כ- ,data על ידי הוספת (100) + IC )עשרוי( לערכו של הסמל. הסיבה לכך היא שבתמוה הכוללת של קוד המכוה, תמות התוים מופרדת מתמות הוראות, וכל התוים דרשים להופיע בקוד המכוה אחרי כל ההוראות. סמל מסוג data הוא תווית בתמות התוים, והעדכון מוסיף לערך הסמל )כלומר לכתובתו בזיכרון( את האורך הכולל של תמות ההוראות, בתוספת כתובת התחלת הטעיה של הקוד, שהיא .100

טבלת הסמלים מכילה כעת את ערכי כל הסמלים החוצים להשלמת תמות הזיכרון )למעט ערכים של סמלים חיצויים.(

במעבר השי, האסמבלר משלים באמצעות טבלת הסמלים את קידוד כל המילים במערך ההוראות שטרם קודדו במעבר הראשון. במודל המכוה שלו אלו הן מילות-מידע וספות של הוראות, אשר מקודדות אופרד בשיטת מיעון ישיר או יחסי.
אלגוריתם שלדי של האסמבלר
לחידוד ההבה של תהליך העבודה של האסמבלר, ציג להלן אלגוריתם שלדי למעבר הראשון ולמעבר השי.

לתשומת לב: אין חובה להשתמש דווקא באלגוריתם זה.
כאמור, או מחלקים את תמות קוד המכוה לשי חלקים: תמות ההוראות ,(code) ותמות התוים .(data) לכל חלק תחזק מוה פרד: IC )מוה ההוראות( וDC- )מוה התוים.(
בה את קוד המכוה כך שיתאים לטעיה לזיכרון החל מכתובת .100
 
בכל מעבר מתחילים לקרוא את קובץ המקור מההתחלה.
מעבר ראשון

 
.DC  0, IC  100
 
.1  אתחל
 
.2 קרא את השורה הבאה מקובץ המקור. אם גמר קובץ המקור, עבור ל- .17 .3 האם השדה הראשון בשורה הוא תווית? אם לא, עבור ל.5-
.4  הדלק דגל "יש הגדרת סמל."
.5  האם זוהי החיה לאחסון תוים, כלומר, האם החית .data או .string ? אם לא, עבור ל-
.8
.6 אם יש הגדרת סמל )תווית,( הכס אותו לטבלת הסמלים עם המאפיין .data ערך הסמל יהיה בסיס והיסט . )אם הסמל איו תווית חוקית, או שהסמל כבר מצא בטבלה, יש להודיע על שגיאה.(
.7 זהה את סוג התוים, קודד אותם בתמות התוים, והגדל את מוה התוים DC על ידי הוספת האורך הכולל של התוים שהוגדרו בשורה הוכחית. חזור ל.2-
.8  האם זו החית .extern או החית .entry ? אם לא, עבור ל.11- .9  אם זוהי החית .entry חזור ל2- )ההחיה תטופל במעבר השי.(
.10 אם זו החית ,.extern הכס את הסמל המופיע כאופרד של ההחיה לתוך טבלת
הסמלים עם פעמיים הערך 0 )בסיס והיסט,( ועם המאפיין .external )אם הסמל איו
תווית חוקית, או שהסמל כבר מצא בטבלה ללא המאפיין ,external יש להודיע על
שגיאה.( חזור ל.2-
.11 זוהי שורת הוראה. אם יש הגדרת סמל )תווית,( הכס אותו לטבלת הסמלים עם המאפיין .code ערכו של הסמל יהיה בסיס והיסט )אם הסמל איו תווית חוקית, או שהסמל כבר מצא בטבלה, יש להודיע על שגיאה.(
.12 חפש את שם הפעולה בטבלת שמות הפעולות, ואם לא מצא, אז הודע על שגיאה בשם ההוראה.
.13 תח את מבה האופרדים של ההוראה, וחשב מהו מספר המילים הכולל שתופסת ההוראה בקוד המכוה )קרא למספר זה .(L
.14 בה כעת את הקוד הביארי של המילה הראשוה של ההוראה, ושל כל מילת-מידע וספת המקודדת אופרד במיעון מיידי. אפשר לקודד גם את המילה השייה בקוד ההוראה )אם קיימת.(
.15 שמור את הערכים IC ו- L יחד עם תוי קוד המכוה של ההוראה. .16 עדכן L + IC  ,IC וחזור ל.2-
.17 קובץ המקור קרא בשלמותו. אם מצאו שגיאות במעבר הראשון, עצור כאן.
.18 שמור את הערכים הסופיים של IC ושל DC )קרא להם ICF ו- .(DCF שתמש בהם לביית קבצי הפלט, אחרי המעבר השי.
.19 עדכן בטבלת הסמלים את ערכו של כל סמל המאופיין כ- data , ע"י שימוש בערך ICF
באופן הבא: ראשית יש לחשב את ערכו המלא המעודכן של הסמל בהיתן
-ICFוהבסיס+היסט הוכחיים )ככל שזה מופיע כך בטבלה,( ואז לחשב בסיס+היסט חדשים.
.20 התחל מעבר שי.
מעבר שי
.1 קרא את השורה הבאה מקובץ המקור. אם גמר קובץ המקור, עבור ל- .7 .2 אם השדה הראשון בשורה הוא סמל )תווית,( דלג עליו.
.3 האם זוהי החית .data או .string או .extern ? אם כן, חזור ל- .1 .4 האם זוהי החית .entry ? אם לא, עבור ל- .6
.5 הוסף בטבלת הסמלים את המאפיין entry למאפייי הסמל המופיע כאופרד של ההחיה )אם הסמל לא מצא בטבלת הסמלים, יש להודיע על שגיאה.( חזור ל- .1
.6  השלם את הקידוד הביארי של מילות-המידע של האופרדים, בהתאם לשיטות המיעון שבשימוש. לכל אופרד בקוד המקור המכיל סמל, מצא את ערכו של הסמל בטבלת הסמלים )אם הסמל לא מצא בטבלה, יש להודיע על שגיאה.( אם הסמל מאופיין ,external הוסף את כתובת מילת-המידע הרלווטית לרשימת מילות-מידע שמתייחסות לסמל חיצוי. לפי הצורך, לחישוב הקידוד והכתובות, אפשר להיעזר בערכים IC וL- של ההוראה, כפי ששמרו במעבר
 
הראשון. חזור ל- .1 לתשומת לב: יש להשלים שתי מילות מידע לכל אופרד. כמו כן, אם
מדובר בסמל חיצוי, יש לרשום בקובץ ext את הכתובות של שתי מילות המידע. לפי הגדרת
השפה, כתובת מילת ההיסט תהיה תמיד עוקבת לכתובת מילת הבסיס )דוגמת קובץ ext בהמשך( .
.7 קובץ המקור קרא בשלמותו. אם מצאו שגיאות במעבר השי, עצור כאן. .8 בה את קבצי הפלט )פרטים וספים בהמשך.(
 
פעיל אלגוריתם זה על תוכית הדוגמה שראיו למעלה )לאחר שלב פרישת המקרואים,( וציג
את הקוד הביארי שמתקבל במעבר ראשון ובמעבר שי. להלן שוב תכית הדוגמה.

; file ps.as
.entry LIST
.extern W	
MAIN:	add	r3, LIST
LOOP:	prn	#48
	lea	STR, r6
	inc	r6
	mov	r3, W
	sub	r1, r4
	bne	END
	cmp	val1, #-6
	bne	END[r15]
	dec	K
.entry MAIN		
	sub	LOOP[r10] ,r14
END:	stop	
STR:	.string	“abcd”
LIST:	.data	6, -9
	.data	-100
.entry K		
K:	.data	31
.extern val1		

בצע מעבר ראשון על הקוד לעיל, ובה את טבלת הסמלים. כמו כן, שלים במעבר זה את הקידוד של כל תמות התוים, ושל המילה הראשוה של כל הוראה )שים לב שיש לקודד גם את המילה השייה.( כמו כן, קודד מילות-מידע וספות של כל הוראה, ככל שקידוד זה איו תלוי בערך של סמל. את מילות-המידע שעדיין לא יתן לקודד במעבר הראשון סמן ב "?" בדוגמה להלן.

Address (decimal)	Source Code	Machine Code (binary)
		19	..	..	..	..	..	..	..	..	..	9	8	7	6	5	4	3	2	1	0
0100	MAIN: add r3, LIST	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0101		0	1	0	0	1	0	1	0	0	0	1	1	1	1	0	0	0	0	0	1
0102		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0103		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0104	LOOP: prn #48	0	1	0	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0
0105		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0106		0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0
0107	lea STR, r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0
0108		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	1	1	0	1	1
0109		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0110		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0111	inc r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0112		0	1	0	0	1	1	0	0	0	0	0	0	0	0	0	1	1	0	1	1
0113	mov r3, W	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1
0114		0	1	0	0	0	0	0	0	0	0	1	1	1	1	0	0	0	0	0	1
0115		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0116		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0117	sub r1, r4	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0118		0	1	0	0	1	0	1	1	0	0	0	1	1	1	0	1	0	0	1	1
0119	bne END	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0120		0	1	0	0	1	0	1	1	0	0	0	0	0	0	0	0	0	0	0	1
 

Address (decimal)	Source Code	Machine Code (binary)
		19	..	..	..	..	..	..	..	..	..	9	8	7	6	5	4	3	2	1	0
0121		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0122		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0123	cmp val1, #-6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
0124		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0
0125		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0126		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0127		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	1	0	1	0
0128	bne END[r15]	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0129		0	1	0	0	1	0	1	1	0	0	0	0	0	0	1	1	1	1	1	0
0130		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0131		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0132	dec K	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0133		0	1	0	0	1	1	0	1	0	0	0	0	0	0	0	0	0	0	0	1
0134		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0135		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0136	sub LOOP[r10],r14	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0137		0	1	0	0	1	0	1	1	1	0	1	0	1	0	1	1	1	0	1	1
0138		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0139		?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?
0140	END: stop	0	1	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0141	STR: .string “abcd”	0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0	1
0142		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	0
0143		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	1
0144		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	1	0	0
0145		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0146	LIST: .data 6, -9	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0
0147		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	0	1	1	1
0148	.data -100	0	1	0	0	1	1	1	1	1	1	1	1	1	0	0	1	1	1	0	0
0149	K:	.data 31	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	1	1	1




טבלת הסמלים אחרי מעבר ראשון היא:

Symbol	Value (decimal)	Base address	offset	Attributes
W	0	0	0	external
MAIN	100	96	4	code, entry
LOOP	104	96	8	code
END	140	128	12	code
STR	141	128	13	data
LIST	146	144	2	data, entry
K	149	144	5	data, entry
val1	0	0	0	external

בצע עתה את המעבר השי. שלים באמצעות טבלת הסמלים את הקידוד החסר במילים המסומות ."?" הקוד הביארי בצורתו הסופית כאן זהה לקוד שהוצג בתחילת הושא "אסמבלר עם שי מעברים."
הערה: כאמור, האסמבלר בוה קוד מכוה כך שיתאים לטעיה לזיכרון החל מכתובת 100 )עשרוי.( אם הטעיה בפועל )לצורך הרצת התוכית( תהיה לכתובת אחרת, יידרשו תיקוים בקוד הביארי בשלב הטעיה, שיוכסו בעזרת מידע וסף שהאסמבלר מכין בקבצי הפלט )ראו בהמשך.(
 

Address (decimal)	Source Code	Machine Code (binary)
		19	..	..	..	..	..	..	..	..	..	9	8	7	6	5	4	3	2	1	0
0100	MAIN: add r3, LIST	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0101		0	1	0	0	1	0	1	0	0	0	1	1	1	1	0	0	0	0	0	1
0102		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	1	0	0	0	0
0103		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
0104	LOOP: prn #48	0	1	0	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0
0105		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0106		0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0
0107	lea STR, r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0
0108		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	1	1	0	1	1
0109		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0110		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	1
0111	inc r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0112		0	1	0	0	1	1	0	0	0	0	0	0	0	0	0	1	1	0	1	1
0113	mov r3, W	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1
0114		0	1	0	0	0	0	0	0	0	0	1	1	1	1	0	0	0	0	0	1
0115		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0116		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0117	sub r1, r4	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0118		0	1	0	0	1	0	1	1	0	0	0	1	1	1	0	1	0	0	1	1
0119	bne END	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0120		0	1	0	0	1	0	1	1	0	0	0	0	0	0	0	0	0	0	0	1
0121		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0122		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0
0123	cmp val1, #-6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
0124		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0
0125		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0126		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0127		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	1	0	1	0
0128	bne END[r15]	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0129		0	1	0	0	1	0	1	1	0	0	0	0	0	0	1	1	1	1	1	0
0130		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0131		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0
0132	dec K	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0133		0	1	0	0	1	1	0	1	0	0	0	0	0	0	0	0	0	0	0	1
0134		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	1	0	0	0	0
0135		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	1
0136	sub LOOP[r10],r14	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0137		0	1	0	0	1	0	1	1	1	0	1	0	1	0	1	1	1	0	1	1
0138		0	0	1	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0	0
0139		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0
0140	END: stop	0	1	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0141	STR: .string “abcd”	0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0	1
0142		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	0
0143		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	1
0144		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	1	0	0
0145		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0146	LIST: .data 6, -9	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0
0147		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	0	1	1	1
0148	.data -100	0	1	0	0	1	1	1	1	1	1	1	1	1	0	0	1	1	1	0	0
0149	K:	.data 31	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	1	1	1
 
טבלת הסמלים אחרי מעבר שי היא:

Symbol	Value (decimal)	Base address	offset	Attributes
W	0	0	0	external
MAIN	100	96	4	code, entry
LOOP	104	96	8	code
END	140	128	12	code
STR	141	128	13	data
LIST	146	144	2	data, entry
K	149	144	5	data, entry
val1	0	0	0	external

בסוף המעבר השי, אם לא תגלו שגיאות, האסמבלר בוה את קבצי הפלט )ראו בהמשך,( שמכילים את הקוד הביארי ומידע וסף עבור שלבי הקישור והטעיה.
כאמור, שלבי הקישור והטעיה אים למימוש בפרויקט זה, ולא דון בהם כאן.

קבצי קלט ופלט של האסמבלר
בהפעלה של האסמבלר, יש להעביר אליו באמצעות ארגומטים של שורת הפקודה
arguments) line (command רשימה של שמות קבצי מקור )אחד או יותר.(
אלו הם קבצי טקסט, ובהם תוכיות בתחביר של שפת האסמבלי שהוגדרה בממ"ן זה. האסמבלר פועל על כל קובץ מקור בפרד, ויוצר עבורו קבצי פלט כדלקמן:
•  קובץ ,am המכיל את קובץ המקור לאחר שלב קדם האסמבלר )לאחר פרישת המקרואים(
•  קובץ ,object המכיל את קוד המכוה.
•  קובץ ,externals ובו פרטים על כל המקומות )הכתובות( בקוד המכוה בהם יש מילת-מידע שמקודדת ערך של סמל שהוצהר כחיצוי )סמל שהופיע כאופרד של החיית ,.extern ומאופיין בטבלת הסמלים כ- .(external
•  קובץ ,entries ובו פרטים על כל סמל שמוצהר כקודת כיסה )סמל שהופיע כאופרד של החיית ,.entry ומאופיין בטבלת הסמלים כ- .(entry
אם אין בקובץ המקור אף החיית ,.extern האסמבלר לא יוצר את קובץ הפלט מסוג .externals אם אין בקובץ המקור אף החיית ,.entry האסמבלר לא יוצר את קובץ הפלט מסוג .entries

שמות קבצי המקור חייבים להיות עם הסיומת .“.as” למשל, השמות x.as , ,y.as וhello.as- הם שמות חוקיים. העברת שמות הקבצים הללו כארגומטים לאסמבלר עשית ללא ציון הסיומת.
לדוגמה: יח שתוכית האסמבלר שלו קראת ,assembler אזי שורת הפקודה הבאה:
assembler x y hello
תריץ את האסמבלר על הקבצים: hello.as y.as, .x.as,
שמות קבצי הפלט מבוססים על שם קובץ הקלט, כפי שהופיע בשורת הפקודה, בתוספת סיומת מתאימה: הסיומת “.am” עבור קובץ לאחר פרישת מאקרו, הסיומת “.ob” עבור קובץ ה,object- הסיומת “.ent” עבור קובץ ה,entries- והסיומת “.ext” עבור קובץ ה.externals-
לדוגמה, בהפעלת האסמבלר באמצעות שורת הפקודה: x assembler
יווצר קובץ פלט ,x.ob וכן קבצי פלט x.ext ו- x.ent ככל שיש החיות .entry או .extern בקובץ המקור. אם אין מאקרו בקובץ המקור, אזי קובץ “.am” יהיה זהה לקובץ “.as” .
ציג כעת את הפורמטים של קבצי הפלט. דוגמאות יובאו בהמשך.
 

תמות ההוראות ראשוה,
 
פורמט קובץ ה- object
קובץ זה מכיל את תמות הזיכרון של קוד המכוה, בשי חלקים: ואחריה ובצמוד תמות התוים.
 
כזכור, האסמבלר מקודד את ההוראות כך שתמות ההוראות תתאים לטעיה החל מכתובת 100 )עשרוי( בזיכרון. שים לב שרק בסוף המעבר הראשון יודעים מהו הגודל הכולל של תמות ההוראות. מכיוון שתמות התוים מצאת אחרי תמות ההוראות, גודל תמות ההוראות משפיע על הכתובות בתמות התוים. זו הסיבה שבגללה היה צורך לעדכן בטבלת הסמלים, בסוף המעבר הראשון, את ערכי הסמלים המאופייים כdata- )כזכור, באלגוריתם השלדי שהוצג לעיל, בצעד ,19 הוספו לכל סמל כזה את הערך .(ICF במעבר השי, בהשלמת הקידוד של מילות-המידע, משתמשים בערכים המעודכים של הסמלים, המותאמים למבה המלא והסופי של תמות הזיכרון.
כעת האסמבלר יכול לכתוב את תמות הזיכרון בשלמותה לתוך קובץ פלט )קובץ ה- .(object
השורה הראשוה בקובץ ה- object היא "כותרת," המכילה שי מספרים )בבסיס עשרוי:( הראשון הוא האורך הכולל של תמות ההוראות )במילות זיכרון,( והשי הוא האורך הכולל של תמות התוים )במילות זיכרון.( בין שי המספרים מפריד רווח אחד.
כזכור, במעבר הראשון, בצעד ,19 שמרו ערכי הסמלים תוך שימוש ב .ICF
השורות הבאות בקובץ מכילות את תמות הזיכרון. בכל שורה זוג שדות: כתובת של מילה
בזיכרון, ותוכן המילה., הכתובת תירשם בבסיס עשרוי בארבע ספרות )כולל אפסים מובילים.(
 
ב3- ספרות )כולל אפסים מובילים.( בין השדות בשורה יש
 
תוכן המילה יירשם בבסיס "מיוחד" רווח אחד.
"בסיס מיוחד"
 
כל שורה בתמות הזיכרון היא באורך 20 סיביות, החל מסיבית 0 )מימין( ועד לסיבית 19 )משמאל.( חלק את 20 הסיביות ל5- קבוצות בות 4 סיביות בכל קבוצה כך:
סיביות 16-19 יקראו קבוצה A
סיביות 12-15 יקראו קבוצה B
סיביות 8-11 יקראו קבוצה C
סיביות 4-7 יקראו קבוצה D
סיביות 0-3 יקראו קבוצה E
כל 4 סיביות של קבוצה מסוימת יומרו לספרה הקסאדצימלית וייכתבו לקובץ הOB- באופן הבא: תחילה ייכתב שם הקבוצה באות גדולה, ולאחריו הייצוג ההקסהדצימלי של סיביות הקבוצה. כך ייכתבו כל הסיביות מכל הקבוצות עם הפרדה של תו מקף (-) בין קבוצה לקבוצה.
לדוגמה, סתכל על 20 הסיביות הבאות:
0	1	0	0	0	0	0	0	0	0	1	1	1	1	0	0	0	0	0	1
הם ייכתבו לקובץ הOB- כך:
A4-B0-C3-Dc-E1

פורמט קובץ הentries-
קובץ הentries- בוי משורות טקסט, שורה אחת לכל סמל שמאופיין בטבלת הסמלים כ- .entry
בשורה מופיע שם הסמל, ולאחריו כתובת הבסיס שלו וההיסט, כפי שקבע בטבלת הסמלים
)בבסיס עשרוי בארבע ספרות, כולל אפסים מובילים.( אין חשיבות לסדר השורות, כי כל שורה עומדת בפי עצמה.
בין השדות בשורה יש פסיק אחד.
 
externals -ה קובץ פורמט
קובץ הexternals- בוי אף הוא משורות טקסט, שורה לכל כתובת בקוד המכוה בה יש מילת מידע המתייחסת לסמל שמאופיין כ- .external כזכור, רשימה של מילות-מידע אלה בתה במעבר השי )צעד 6 באלגוריתם השלדי.(

כל שורה בקובץ הexternals- מכילה את שם הסמל החיצוי, ולאחריו המילה BASE ולאחריה הכתובת של מילת-המידע בקוד המכוה בה דרשת כתובת הבסיס )בבסיס עשרוי בארבע ספרות, כולל אפסים מובילים.( ולאחר מכן, שורה וספת המכילה את שם הסמל החיצוי, ולאחריו המילה OFFSET ולאחריה הכתובת של מילת-המידע בקוד המכוה בה דרש ההיסט (OFFSET) )בבסיס עשרוי בארבע ספרות, כולל אפסים מובילים.(
בין השדות בשורה יש רווח אחד. אין חשיבות לסדר השורות, כי כל שורה עומדת בפי עצמה.
לתשומת לב: ייתכן ויש מספר כתובות בקוד המכוה בהן מילות-המידע מתייחסות לאותו סמל
חיצוי.  לכל  כתובת  כזו  תהיה  שורה  פרדת  בקובץ  ה.externals- דגים את הפלט שמייצר האסמבלר עבור קובץ מקור בשם ps.as שהודגם קודם לכן. 
	התוכית לאחר שלב פרישת המקרו תיראה כך:

; file ps.am		
.entry LIST		
.extern W		
MAIN:	add	r3, LIST
LOOP:








.entry MAIN
END:	prn lea inc mov sub bne cmp bne dec

sub stop	#48
STR, r6
r6
r3, W
r1, r4 END
val1, #-6 END[r15] K

LOOP[r10] ,r14
STR:	.string	“abcd”
LIST:	.data	6, -9

.entry K	.data	-100
K:
.extern val1	.data	31
 
להלן הקידוד הביארי המלא )תמות הזיכרון( של קובץ המקור, בגמר המעבר השי.

Address (decimal)	Source Code	Machine Code (binary)
		19	..	..	..	..	..	..	..	..	..	9	8	7	6	5	4	3	2	1	0
0100	MAIN: add r3, LIST	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0101		0	1	0	0	1	0	1	0	0	0	1	1	1	1	0	0	0	0	0	1
0102		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	1	0	0	0	0
0103		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
0104	LOOP: prn #48	0	1	0	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0
0105		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0106		0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0
0107	lea STR, r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0
0108		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	1	1	0	1	1
0109		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0110		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	1
0111	inc r6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0112		0	1	0	0	1	1	0	0	0	0	0	0	0	0	0	1	1	0	1	1
0113	mov r3, W	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1
0114		0	1	0	0	0	0	0	0	0	0	1	1	1	1	0	0	0	0	0	1
0115		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0116		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0117	sub r1, r4	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0118		0	1	0	0	1	0	1	1	0	0	0	1	1	1	0	1	0	0	1	1
0119	bne END	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0120		0	1	0	0	1	0	1	1	0	0	0	0	0	0	0	0	0	0	0	1
0121		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0122		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0
0123	cmp val1, #-6	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
0124		0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0
0125		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0126		0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0127		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	1	0	1	0
0128	bne END[r15]	0	1	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0129		0	1	0	0	1	0	1	1	0	0	0	0	0	0	1	1	1	1	1	0
0130		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
0131		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0
0132	dec K	0	1	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
0133		0	1	0	0	1	1	0	1	0	0	0	0	0	0	0	0	0	0	0	1
0134		0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	1	0	0	0	0
0135		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	1
0136	sub LOOP[r10],r14	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
0137		0	1	0	0	1	0	1	1	1	0	1	0	1	0	1	1	1	0	1	1
0138		0	0	1	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0	0
0139		0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0
0140	END: stop	0	1	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0141	STR: .string “abcd”	0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	0	1
0142		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	0
0143		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	0	1	1
0144		0	1	0	0	0	0	0	0	0	0	0	0	0	1	1	0	0	1	0	0
0145		0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0146	LIST: .data 6, -9	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	0
0147		0	1	0	0	1	1	1	1	1	1	1	1	1	1	1	1	0	1	1	1
0148	.data -100	0	1	0	0	1	1	1	1	1	1	1	1	1	0	0	1	1	1	0	0
0149	K:	.data 31	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	1	1	1
 
טבלת הסמלים בגמר המעבר השי היא:

Symbol	Value (decimal)	Base address	offset	Attributes
W	0	0	0	external
MAIN	100	96	4	code, entry
LOOP	104	96	8	code
END	140	128	12	code
STR	141	128	13	data
LIST	146	144	2	data, entry
K	149	144	5	data, entry
val1	0	0	0	external




להלן תוכן קבצי הפלט של הדוגמה.
:ps.ob הקובץ

41	9
0100	A4-B0-C0-D0-E4
0101	A4-Ba-C3-Dc-E1
0102	A2-B0-C0-D9-E0
0103	A2-B0-C0-D0-E2
0104	A4-B2-C0-D0-E0
0105	A4-B0-C0-D0-E0
0106	A4-B0-C0-D3-E0
0107	A4-B0-C0-D1-E0
0108	A4-B0-C0-D5-Eb
0109	A2-B0-C0-D8-E0
0110	A2-B0-C0-D0-Ed
0111	A4-B0-C0-D2-E0
0112	A4-Bc-C0-D1-Eb
0113	A4-B0-C0-D0-E1
0114	A4-B0-C3-Dc-E1
0115	A1-B0-C0-D0-E0
0116	A1-B0-C0-D0-E0
0117	A4-B0-C0-D0-E4
0118	A4-Bb-C1-Dd-E3
0119	A4-B0-C2-D0-E0
0120	A4-Bb-C0-D0-E1
0121	A2-B0-C0-D8-E0
0122	A2-B0-C0-D0-Ec
0123	A4-B0-C0-D0-E2
0124	A4-B0-C0-D4-E0
0125	A1-B0-C0-D0-E0
0126	A1-B0-C0-D0-E0
0127	A4-Bf-Cf-Df-Ea
0128	A4-B0-C2-D0-E0
0129	A4-Bb-C0-D3-Ee
 
0130	A2-B0-C0-D8-E0
0131	A2-B0-C0-D0-Ec
0132	A4-B0-C0-D2-E0
0133	A4-Bd-C0-D0-E1
0134	A2-B0-C0-D9-E0
0135	A2-B0-C0-D0-E5
0136	A4-B0-C0-D0-E4
0137	A4-Bb-Ca-Db-Eb
0138	A2-B0-C0-D6-E0
0139	A2-B0-C0-D0-E8
0140	A4-B8-C0-D0-E0
0141	A4-B0-C0-D6-E1
0142	A4-B0-C0-D6-E2
0143	A4-B0-C0-D6-E3
0144	A4-B0-C0-D6-E4
0145	A4-B0-C0-D0-E0
0146	A4-B0-C0-D0-E6
0147	A4-Bf-Cf-Df-E7
0148	A4-Bf-Cf-D9-Ec
0149	A4-B0-C0-D1-Ef









:ps.ent הקובץ	:ps.ext הקובץ

 
MAIN,96,4 LIST,144,2 K,144,5
 
W BASE 115
W OFFSET 116

val1 BASE 125
val1 OFFSET 126
 
סיכום והחיות כלליות


•  גודל תוכית המקור היתת כקלט לאסמבלר איו ידוע מראש, ולכן גם גודלו של קוד המכוה איו צפוי מראש. אולם בכדי להקל במימוש האסמבלר, מותר להיח גודל מקסימלי. לפיכך יש אפשרות להשתמש במערכים לאכסון תמות קוד המכוה בלבד. כל מבה תוים אחר )למשל טבלת הסמלים וטבלת המקרו,( יש לממש באופן יעיל וחסכוי )למשל באמצעות רשימה מקושרת והקצאת זיכרון דיאמי.(
•  השמות של קבצי הפלט צריכים להיות תואמים לשם קובץ הקלט, למעט הסיומות. למשל,
אם קובץ הקלט הוא prog.as אזי קבצי הפלט שיווצרו הם: prog.ent prog.ext, prog.ob,

•  מתכות הפעלת האסמבלר צריכה להיות כפי הדרש בממ"ן, ללא שיויים כלשהם.
כלומר, ממשק המשתמש יהיה אך ורק באמצעות שורת הפקודה. בפרט, שמות קבצי המקור יועברו לתוכית האסמבלר כארגומטים )אחד או יותר( בשורת הפקודה. אין להוסיף תפריטי קלט איטראקטיביים, חלוות גרפיים למייהם, וכד.'

•  יש להקפיד לחלק את מימוש האסמבלר למספר מודולים )קבצים בשפת (C לפי משימות. אין לרכז משימות מסוגים שוים במודול יחיד. מומלץ לחלק למודולים כגון: מעבר ראשון, מעבר שי, פוקציות עזר )למשל, תרגום לבסיס, יתוח תחבירי של שורה,( טבלת הסמלים, מפת הזיכרון, טבלאות קבועות )קודי הפעולה, שיטות המיעון החוקיות לכל פעולה, וכד.('

•  יש להקפיד ולתעד את המימוש באופן מלא וברור, באמצעות הערות מפורטות בקוד.
•  יש לאפשר תווים לבים עודפים בקובץ הקלט בשפת אסמבלי. למשל, אם בשורת הוראה יש שי אופרדים המופרדים בפסיק, אזי לפי ואחרי הפסיק מותר שיהיו רווחים וטאבים בכל כמות. בדומה, גם לפי ואחרי שם הפעולה. מותרות גם שורות ריקות. האסמבלר יתעלם מתווים לבים מיותרים )כלומר ידלג עליהם.(
•  הקלט )קוד האסמבלי( עלול להכיל שגיאות תחביריות. על האסמבלר לגלות ולדווח על כל השורות השגויות בקלט. אין לעצור את הטיפול בקובץ קלט לאחר גילוי השגיאה הראשוה. יש להדפיס למסך הודעות מפורטות ככל היתן, כדי שאפשר יהיה להבין מה והיכן כל שגיאה. כמובן שאם קובץ קלט מכיל שגיאות, אין טעם להפיק עבורו את קבצי הפלט ent) ext, .(ob,


תם ושלם פרק ההסברים והגדרת הפרויקט.

בשאלות יתן לפות לקבוצת הדיון באתר הקורס, ואל כל אחד מהמחים בשעות הקבלה שלהם.
להזכירכם, באפשרותו של כל סטודט לפות לכל מחה, לאו דווקא למחה הקבוצה שלו, לקבלת עזרה. שוב מומלץ לכל אלה שטרם בדקו את התכים באתר הקורס לעשות זאת. שאלות באתר זה הרבה שאלות בושא חומר הלימוד והממ"ים, והתשובות יכולות להועיל לכולם.

לתשומת לבכם: לא תיתן דחיה בהגשת הממ"ן, פרט למקרים מיוחדים כגון מילואים או מחלה
ממושכת. במקרים אלו יש לבקש ולקבל אישור מראש מצוות הקורס.


ב ה צ ל ח ה !
